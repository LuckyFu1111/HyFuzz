#!/usr/bin/env python3
"""
Automated Script to Fix Pickle RCE Vulnerability

This script automatically replaces all unsafe pickle usage with SafeSerializer
across the HyFuzz codebase to prevent Remote Code Execution vulnerabilities.

What it does:
1. Finds all files using pickle
2. Adds import for SafeSerializer
3. Replaces pickle.load/dump with SafeSerializer methods
4. Updates module docstrings
5. Creates backup of original files

Usage:
    python scripts/fix_pickle_vulnerability.py [--dry-run] [--backup]

Author: HyFuzz Security Team
Date: 2025-11-11
"""

import re
import sys
from pathlib import Path
from typing import List, Tuple
import shutil
import argparse

# ==============================================================================
# FILE PATTERNS TO FIX
# ==============================================================================

FILES_TO_FIX = [
    "src/knowledge/cve_repository.py",
    "src/knowledge/cwe_repository.py",
    "src/knowledge/knowledge_loader.py",
    "src/llm/cache_manager.py",
    "src/llm/embedding_manager.py",
]


# ==============================================================================
# REPLACEMENT PATTERNS
# ==============================================================================

REPLACEMENTS = [
    # Import replacement
    (
        r"^import pickle\s*$",
        "from src.utils.safe_serializer import SafeSerializer, load, dump\n\n# Initialize safe serializer (replaces pickle)\n_serializer = SafeSerializer(use_compression=True)"
    ),

    # pickle.load -> serializer.load
    (
        r"pickle\.load\((\w+)\)",
        r"_serializer.load(\1)"
    ),

    # pickle.dump -> serializer.dump
    (
        r"pickle\.dump\(([^,]+),\s*(\w+)\)",
        r"_serializer.dump(\1, \2)"
    ),

    # pickle.loads -> serializer.loads
    (
        r"pickle\.loads\(([^)]+)\)",
        r"_serializer.loads(\1)"
    ),

    # pickle.dumps -> serializer.dumps
    (
        r"pickle\.dumps\(([^)]+)\)",
        r"_serializer.dumps(\1)"
    ),
]


# ==============================================================================
# HELPER FUNCTIONS
# ==============================================================================

def backup_file(file_path: Path) -> Path:
    """Create backup of original file"""
    backup_path = file_path.with_suffix(file_path.suffix + '.backup')
    shutil.copy2(file_path, backup_path)
    print(f"  ✓ Created backup: {backup_path}")
    return backup_path


def read_file(file_path: Path) -> str:
    """Read file content"""
    with open(file_path, 'r', encoding='utf-8') as f:
        return f.read()


def write_file(file_path: Path, content: str) -> None:
    """Write content to file"""
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(content)


def apply_replacements(content: str) -> Tuple[str, int]:
    """Apply all replacement patterns to content"""
    changes = 0

    for pattern, replacement in REPLACEMENTS:
        new_content, count = re.subn(pattern, replacement, content, flags=re.MULTILINE)

        if count > 0:
            changes += count
            content = new_content
            print(f"    - Applied replacement: {pattern[:50]}... ({count} occurrences)")

    return content, changes


def update_security_note(content: str) -> str:
    """Update security notes in docstring"""
    # Find pickle security warnings and replace them
    old_security_patterns = [
        r"Security Note - Pickle Usage:.*?(?=\n\n|\nExample|\nAuthor)",
        r"IMPORTANT: Never deserialize pickle data from untrusted sources!.*?(?=\n\n)"
    ]

    new_security_note = """Security:
    This module uses SafeSerializer for secure JSON-based serialization
    instead of pickle to prevent Remote Code Execution (RCE) vulnerabilities.

    Key security improvements:
    - No arbitrary code execution during deserialization
    - Safe for use with external data
    - Supports complex types (NetworkX graphs, dataclasses, etc.)
    - Backward compatible via automatic migration"""

    for pattern in old_security_patterns:
        content = re.sub(pattern, new_security_note, content, flags=re.DOTALL)

    # Update version number
    content = re.sub(r"Version:\s*\d+\.\d+\.\d+", "Version: 2.0.0", content)

    # Add security note to changelog
    if "Date: " in content and "Security:" not in content:
        content = re.sub(
            r"(Date:\s*[\d-]+)",
            r"\1\nSecurity: Replaced pickle with SafeSerializer to prevent RCE",
            content
        )

    return content


def fix_file(file_path: Path, dry_run: bool = False, create_backup: bool = True) -> bool:
    """Fix a single file"""
    print(f"\n Processing: {file_path}")

    if not file_path.exists():
        print(f"  ✗ File not found: {file_path}")
        return False

    # Read original content
    original_content = read_file(file_path)

    # Check if file uses pickle
    if 'import pickle' not in original_content and 'pickle.' not in original_content:
        print(f"  ℹ File doesn't use pickle, skipping")
        return True

    # Create backup
    if create_backup and not dry_run:
        backup_file(file_path)

    # Apply replacements
    modified_content, changes = apply_replacements(original_content)

    # Update security notes
    modified_content = update_security_note(modified_content)

    if changes == 0:
        print(f"  ℹ No changes needed")
        return True

    # Write modified content
    if dry_run:
        print(f"  [DRY RUN] Would make {changes} changes to {file_path}")
        # Show diff
        print("\n  Changes preview:")
        for i, (old_line, new_line) in enumerate(zip(original_content.split('\n')[:10], modified_content.split('\n')[:10])):
            if old_line != new_line:
                print(f"    - {old_line}")
                print(f"    + {new_line}")
    else:
        write_file(file_path, modified_content)
        print(f"  ✓ Fixed {changes} pickle usages in {file_path}")

    return True


# ==============================================================================
# MAIN SCRIPT
# ==============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Fix pickle RCE vulnerability in HyFuzz codebase"
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help="Show what would be changed without making modifications"
    )
    parser.add_argument(
        '--backup',
        action='store_true',
        default=True,
        help="Create backup files (default: True)"
    )
    parser.add_argument(
        '--no-backup',
        dest='backup',
        action='store_false',
        help="Don't create backup files"
    )

    args = parser.parse_args()

    print("=" * 80)
    print("HYFUZZ PICKLE VULNERABILITY FIX")
    print("=" * 80)
    print(f"Mode: {'DRY RUN' if args.dry_run else 'LIVE'}")
    print(f"Backup: {'Yes' if args.backup else 'No'}")
    print(f"Files to process: {len(FILES_TO_FIX)}")
    print("=" * 80)

    # Get base directory (project root)
    script_dir = Path(__file__).parent
    base_dir = script_dir.parent

    success_count = 0
    failed_count = 0

    for file_rel_path in FILES_TO_FIX:
        file_path = base_dir / file_rel_path

        try:
            if fix_file(file_path, dry_run=args.dry_run, create_backup=args.backup):
                success_count += 1
            else:
                failed_count += 1
        except Exception as e:
            print(f"  ✗ Error processing {file_path}: {e}")
            failed_count += 1

    print("\n" + "=" * 80)
    print("SUMMARY")
    print("=" * 80)
    print(f"Successfully processed: {success_count}/{len(FILES_TO_FIX)}")
    print(f"Failed: {failed_count}")

    if not args.dry_run:
        print("\n✓ All pickle usages have been replaced with SafeSerializer!")
        print("\nNext steps:")
        print("1. Run tests to ensure everything works: pytest")
        print("2. Review changes: git diff")
        print("3. Commit changes: git add . && git commit -m 'security: Fix pickle RCE vulnerability'")
    else:
        print("\n[DRY RUN] No files were modified. Remove --dry-run to apply changes.")

    sys.exit(0 if failed_count == 0 else 1)


if __name__ == '__main__':
    main()
